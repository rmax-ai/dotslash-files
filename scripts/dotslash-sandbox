#!/usr/bin/env bash
set -euo pipefail

# dotslash-sandbox: Run a .dotslash file in a Podman container.
#
# This script sets up a secure, isolated environment using Podman to execute
# the specified .dotslash file. Behaviour notes for developers:
# - The current working directory is mounted read-only into the container to
#   avoid accidental host modifications while allowing tools to run against
#   repository files.
# - A per-user cache is exposed at $HOME/.cache/dotslash-sandbox and mounted
#   into the container as a temporary download cache to speed repeated fetches.
# - A small `dotslash` shim is injected into the container to allow fetching
#   and verifying artifacts inside the sandbox.
# - The container is run with reduced privileges, limited resources, and a
#   minimal writable surface; when extending behaviour, keep mounts and env
#   variables opt-in and documented to preserve isolation and reproducibility.
#
# Keep the help text and usage examples in the top-of-file HELP block below.

HELP=$(cat <<'EOF'
Dotslash Sandbox - Run a .dotslash file in a Podman container.

Usage:
  ./dotslash-sandbox <file.dotslash> [args...]

Example:
  SANDBOX_OFFLINE=1 ./dotslash-sandbox tool.dotslash -- arg1 arg2

Environment variables (optional):
  SANDBOX_ADDITIONAL_PATH - host path to bind as an extra bin directory inside the container (read-only)
  SANDBOX_OFFLINE         - if set (non-empty), run container with networking disabled (e.g., SANDBOX_OFFLINE=1)
  SANDBOX_ENV             - space-separated list of environment variable names to pass through into the container (e.g., SANDBOX_ENV='HTTP_PROXY HTTPS_PROXY')
  SANDBOX_OUTPUT          - host directory path to mount as /output inside the container (read-write)
  SANDBOX_ALLOW_EMULATION - set to 1 to allow running a different platform (emulated) when SANDBOX_PLATFORM is set
  PODMAN_BIN              - path to the podman executable to use (default: podman)
  SANDBOX_IMAGE           - container image to run (default: fedora:latest)
  SANDBOX_CACHE_DIR       - override base cache dir (default: $HOME/.cache/dotslash-sandbox)

Notes:
  - The cache is split per platform (e.g., $HOME/.cache/dotslash-sandbox/linux-amd64) to avoid cross-platform
    cache corruption when images or rewrites differ between architectures.
EOF
)

# Print help if requested
if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    echo "$HELP" >&2
    exit 0
fi

if [[ $# -lt 1 ]]; then
    echo "$HELP" >&2
    exit 1
fi

DOTSLASH_FILE="$1"
SANDBOX_ADDITIONAL_PATH="${SANDBOX_ADDITIONAL_PATH:-}"
SANDBOX_OFFLINE="${SANDBOX_OFFLINE:-}"
SANDBOX_ENV="${SANDBOX_ENV:-}"
SANDBOX_OUTPUT="${SANDBOX_OUTPUT:-}"
PODMAN_BIN="${PODMAN_BIN:-podman}"
shift 1

# Platform selection:
# - If SANDBOX_PLATFORM is explicitly set, the script will try to use it.
# - By default, we use the host platform (no --platform arg passed to podman).
# - If the requested SANDBOX_PLATFORM differs from the host platform, we will
#   *by default* prefer the host platform (to avoid slow emulation). To allow
#   emulation (e.g., run linux/amd64 on an arm host), set
#   SANDBOX_ALLOW_EMULATION=1 in the environment.
SANDBOX_PLATFORM="${SANDBOX_PLATFORM:-}"

# Normalize host platform (linux/amd64, linux/arm64)
HOST_UNAME="$(uname -m)"
case "$HOST_UNAME" in
    x86_64|amd64) HOST_PLATFORM="linux/amd64" ;;
    aarch64|arm64) HOST_PLATFORM="linux/arm64" ;;
    *) HOST_PLATFORM="linux/$(echo "$HOST_UNAME" | tr A-Z a-z)" ;;
esac

# If SANDBOX_PLATFORM is explicitly set and differs from the host, handle
# mismatch according to SANDBOX_ALLOW_EMULATION.
if [[ -n "$SANDBOX_PLATFORM" ]]; then
    if [[ "$SANDBOX_PLATFORM" != "$HOST_PLATFORM" ]]; then
        if [[ "${SANDBOX_ALLOW_EMULATION:-}" != "1" ]]; then
            echo "Note: requested platform '$SANDBOX_PLATFORM' differs from host '$HOST_PLATFORM'." >&2
            echo "Defaulting to host platform '$HOST_PLATFORM' to avoid emulation." >&2
            echo "Set SANDBOX_ALLOW_EMULATION=1 to permit running '$SANDBOX_PLATFORM' via emulation." >&2
            # Unset SANDBOX_PLATFORM so we don't pass --platform to podman
            SANDBOX_PLATFORM=""
        else
            echo "Using requested platform via emulation: $SANDBOX_PLATFORM" >&2
        fi
    else
        echo "Using platform: $SANDBOX_PLATFORM"
    fi
fi


# Resolve absolute path of the dotslash file and its directory
ABS_FILE_PATH=$(realpath "$DOTSLASH_FILE")
FILE_DIR=$(dirname "$ABS_FILE_PATH")
FILE_NAME=$(basename "$ABS_FILE_PATH")

# Container paths
WORK_DIR="/work"
# Base cache dir (platform-specific suffix added below)
HOST_CACHE_BASE="${SANDBOX_CACHE_DIR:-$HOME/.cache/dotslash-sandbox}"
CONTAINER_CACHE="/tmp/dotslash-cache"
CONTAINER_HOME="/home/$(whoami)"
CONTAINER_BIN="$CONTAINER_HOME/.local/bin"
SHIM_PATH="$(realpath "$(dirname "$0")/dotslash-shim")"

# Determine the effective platform (use host platform by default unless
# SANDBOX_PLATFORM was accepted above -- see logic above). This must happen
# before we create the platform-specific cache directory.
if [[ -n "$SANDBOX_PLATFORM" ]]; then
    EFFECTIVE_PLATFORM="$SANDBOX_PLATFORM"
else
    EFFECTIVE_PLATFORM="$HOST_PLATFORM"
fi

# Use a platform-specific cache directory to avoid cross-platform issues
PLATFORM_TAG="${EFFECTIVE_PLATFORM//\//-}"
HOST_CACHE="$HOST_CACHE_BASE/$PLATFORM_TAG"
HOST_BIN_CACHE="$HOST_CACHE/bin"

mkdir -p "$HOST_BIN_CACHE"

# Host UID/GID for ownership-aware mounts
HOST_UID="$(id -u)"
HOST_GID="$(id -g)"

# Create a temporary host home directory for the container and make it writable
# by the host user. This avoids permission-denied errors when the shim attempts
# to create $HOME/.cache inside the container.
# We use a directory in the current workspace to ensure it is shared with the Podman VM.
HOST_TMP_HOME=$(mktemp -d "$PWD/.sandbox-home.XXXXXX")
chown "$HOST_UID:$HOST_GID" "$HOST_TMP_HOME" || true
trap 'rm -rf "$HOST_TMP_HOME"' EXIT

# Base container command
PODMAN_ARGS=(
    run --rm -it
    --userns=keep-id
    --security-opt=no-new-privileges
    --cap-drop=all
    --read-only
    --tmpfs /tmp
    --cpus=1.0
    --pids-limit=128
    -v "$PWD:$WORK_DIR:ro"
    -v "$ABS_FILE_PATH:/target/$FILE_NAME:ro"
    -v "$SHIM_PATH:/usr/local/bin/dotslash:ro"
    -v "$HOST_CACHE:$CONTAINER_CACHE"
    -v "$HOST_BIN_CACHE:$CONTAINER_BIN"
    -v "$HOST_TMP_HOME:$CONTAINER_HOME:rw"
    -e "DOTSLASH_CACHE=$CONTAINER_CACHE"
    -e "USER=$(whoami)"
    -e "HOME=$CONTAINER_HOME"
    -e "TERM=${TERM:-xterm-256color}"
    -w "$WORK_DIR"
)

# Handle offline mode
if [[ -n "$SANDBOX_OFFLINE" ]]; then
    PODMAN_ARGS+=( --network none )
fi

# Handle environment passthrough
for var in $SANDBOX_ENV; do
    PODMAN_ARGS+=( -e "$var" )
done

# Handle output mount
if [[ -n "$SANDBOX_OUTPUT" ]]; then
    ABS_OUTPUT=$(realpath "$SANDBOX_OUTPUT")
    mkdir -p "$ABS_OUTPUT"
    PODMAN_ARGS+=( -v "$ABS_OUTPUT:/output:rw" )
fi

# Handle optional bin directory
ENV_PATH="$CONTAINER_BIN:$WORK_DIR:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

if [[ -n "$SANDBOX_ADDITIONAL_PATH" ]]; then
    ABS_ADDITIONAL_PATH=$(realpath "$SANDBOX_ADDITIONAL_PATH")
    CONTAINER_ADDITIONAL_PATH="/extra_bin"
    PODMAN_ARGS+=( -v "$ABS_ADDITIONAL_PATH:$CONTAINER_ADDITIONAL_PATH:ro" )
    ENV_PATH="$CONTAINER_ADDITIONAL_PATH:$ENV_PATH"
fi

if [[ -n "$SANDBOX_OUTPUT" ]]; then
    ENV_PATH="/output:$ENV_PATH"
fi

# Run the container
# We use fedora as it typically includes curl and tar by default,
# unlike debian-slim, while being very compatible with DotSlash.
SANDBOX_IMAGE="${SANDBOX_IMAGE:-fedora:latest}"

# Always specify the platform to avoid mismatched image warnings and ensure
# we use the intended architecture (either host default or requested emulation).
"$PODMAN_BIN" "${PODMAN_ARGS[@]}" --platform "$EFFECTIVE_PLATFORM" \
    --env "PATH=$ENV_PATH" \
    "$SANDBOX_IMAGE" "/target/$FILE_NAME" "$@"
